<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Rochelle Salazar">

<title>Problem Solving and Reasoning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Module_files/libs/clipboard/clipboard.min.js"></script>
<script src="Module_files/libs/quarto-html/quarto.js"></script>
<script src="Module_files/libs/quarto-html/popper.min.js"></script>
<script src="Module_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Module_files/libs/quarto-html/anchor.min.js"></script>
<link href="Module_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Module_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Module_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Module_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Module_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Problem Solving and Reasoning</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Rochelle Salazar </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<div class="border">
<p>Subject: General Mathematics</p>
</div>
<section id="i.-lesson-overview" class="level2">
<h2 class="anchored" data-anchor-id="i.-lesson-overview">I. LESSON OVERVIEW</h2>
<p>Mathematics seeks to understand patterns that permeate the world and human mind. Even if the language of mathematics is based on rules, it is important to motivate students to move beyond rules to be able to convey things in the language of mathematics. This transformation implies changes which involve revitalized effort to focus on seeking solutions, exploring patterns and formulating inferences. Learners will have opportunities to study mathematics as an exploratory, dynamic, evolving discipline. They will be encouraged to perceive mathematics as a science and to appreciate mathematics as a discipline about patterns and not merely about numbers.</p>
</section>
<section id="ii.-lesson-content" class="level2">
<h2 class="anchored" data-anchor-id="ii.-lesson-content">II. LESSON CONTENT</h2>
<p>Mathematics consists of skills and processes. The skills include the basic arithmetical processes and the algorithms that go with them, while processes are the ways of applying these skills. Problem solving is a mathematical process and it contributes to mathematics itself.</p>
<p>A.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Inductive and deductive reasoning</p>
<p>B.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Intuition, proof and certainty</p>
<p>C.&nbsp;&nbsp;&nbsp;&nbsp; Polya’s four steps in problem solving</p>
<p>D.&nbsp;&nbsp;&nbsp;&nbsp; Problem solving strategies</p>
<p>E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mathematical problems involving patterns</p>
<p>F.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Recreational problems using mathematics</p>
<section id="inductive-and-deductive-reasoning" class="level3">
<h3 class="anchored" data-anchor-id="inductive-and-deductive-reasoning">Inductive and Deductive Reasoning</h3>
<p>Mathematical reasoning enables a student to use all other mathematical skills. With mathematical reasoning, students recognize that mathematics is indispensable; that it makes sense and it can be understood. They then learn how to evaluate situations, opt for appropriate problem-solving strategies, draw logical conclusions, develop and describe solutions, and identify when those solutions can be applied.</p>
<p>Inductive and deductive reasoning are two fundamental types of reasoning for mathematicians. <strong>Inductive reasoning</strong> refers to the process of making generalized decisions after observing and/or witnessing, repeated specific instances of something. Conversely, <strong>deductive reasoning</strong> refers to the process of taking the information gathered from general observations and making specific decisions based on that information.</p>
<p>Inductive reasoning is a process of reaching conclusions based on a series of observations while deductive reasoning is a process of reaching conclusions based on previously known facts. Inductive reasoning usually leads to deductive reasoning. A conclusion reached by inductive reasoning may or may not be valid. The conclusions reached by deductive reasoning are correct and valid. Inductive reasoning is used to form hypotheses, while deductive reasoning is used to prove ideas.</p>
<p>Whereas inductive reasoning draws general principles from specific instances, deductive reasoning draws specific conclusions from general principles or premises. A premise is a previous statement or propositions from which another is inferred or follows as a conclusion. Unlike inductive reasoning, which always involves uncertainty. Scientists use inductive reasoning to formulate hypothesis and theories, and deductive reasoning when applying them to specific situations. Even if all the premises are true in a statement, inductive reasoning may still yield false conclusion.</p>
<p><strong>Examples of Deductive Reasoning:</strong></p>
<table class="table">
<colgroup>
<col style="width: 101%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>1st Premise: All numbers ending in 0 or 5 are divisible by 5.</p>
<p>2nd Premise: The number 35 ends with a 5</p>
<p>Conclusion: Therefore, 35 is divisible by 5</p></td>
</tr>
<tr class="even">
<td><p>1st Premise: All squares are rectangles</p>
<p>2nd Premise: All rectangles have four sides</p>
<p>Conclusion: Therefore, all squares have four sides</p></td>
</tr>
<tr class="odd">
<td><p>1st Premise: Cacti are plants</p>
<p>2nd Premise: All plants perform photosynthesis</p>
<p>Conclusion: Therefore, cacti perform photosynthesis</p></td>
</tr>
<tr class="even">
<td><p>1st Premise: All men are mortal</p>
<p>2nd Premise: Algebra teachers are men</p>
<p>Conclusion: Therefore, algebra teachers are mortal</p></td>
</tr>
<tr class="odd">
<td><p>1st Premise: Some students of NVSU are taking up BSED Mathematics</p>
<p>2nd Premise: Students of this University are scholars</p>
<p>Conclusion: Therefore, students taking up BSED Mathematics in this University are scholars.</p></td>
</tr>
</tbody>
</table>
<p><strong>Examples of Inductive Reasoning</strong></p>
<table class="table">
<colgroup>
<col style="width: 95%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>1st Premise: Jaime is an excellent swimmer</p>
<p>2nd Premise: Jaime’s family has a swimming pool</p>
<p>Conclusion: Jaime’s sister, Mary must also be an excellent swimmer</p></td>
</tr>
<tr class="even">
<td><p>1st Premise: David is good looking</p>
<p>2nd Premise: David is well-behaved</p>
<p>Conclusion: Therefore, all good looking is well-behaved</p></td>
</tr>
<tr class="odd">
<td><p>1st Premise: Children in the day care center are playful</p>
<p>2nd Premise: Children in the day care center like to play Legos</p>
<p>Conclusion: Therefore, playful children like to play Legos</p></td>
</tr>
<tr class="even">
<td><p>1st Premise: A coin pulled from a bag is a penny</p>
<p>2nd Premise: The second coin from the bag is a penny</p>
<p>Conclusion: Therefore, all the coins in the bag are pennies</p></td>
</tr>
</tbody>
</table>
<p><strong>Intuition, Proof, and Certainty</strong></p>
<p><strong>Intuition</strong> is the ability to understand something instinctively, without the need for conscious reasoning. It is instinctive knowledge, meaning the state of being aware of or knowing something without having to discover or perceive it, or the ability to do this. It is the instinctive belief, meaning that something is known or believed instinctively, without actual evidence for it.</p>
<p>In the traditional way of dealing with mathematics, mathematicians use their intuition and imagination to come up with theorems. Then, they do a lot of work to try to fill in the proofs and check what’s true.</p>
<p>A <strong>mathematical proof</strong> is an argument which convinces other people that something is true. <strong>Proof</strong> is an inferential argument for a mathematical statement. It is a conclusive evidence or an argument that serves to establish a fact or the truth of something. Proof consists of a test or trial of something to establish that it is true.</p>
<p>In direct proof, the conclusion is established by logically combining the axioms, definitions and earlier theorems.</p>
<p>For example, direct proof can be used to establish that the sum of two even integers is always even: consider two even integers x and y. Since they are even, they can be written as x = 2a and y = 2b, respectively, for integers a and b. then the sum x + y = 2a + 2b = 2(a+b). Therefore, x + y has 2 as a factor and, by definition, is even. Hence the sum of any two integers is even. This proof uses the definition of even integers, the integer properties of closure under addition and multiplication and distributive.</p>
<p><strong>Certainty</strong> is total continuity and validity of inquiries to the highest degree of precision. Certainty is a conclusion or outcome that is beyond doubt. A mathematical certainty is something that is certain or most likely to happen</p>
<p><strong>Polya’s Four Steps to Problem Solving</strong> Problem solving is an artistic science! There is no single approach in problem solving that works all the time. Each problem is slightly different. George Polya (1887-1985), known as the father of modern problem solving who did extensive studies and wrote papers and books about problem solving, formulated the four-step approach to problem solving. Polya’s four-step approach to problem solving aims to make individuals as better problem solvers.</p>
<p>Given below is a detailed framework for thinking about problem solving: Polya’s four-step approach:</p>
<ol type="1">
<li><strong>Preparation</strong>: Understand the problem</li>
</ol>
<ol type="a">
<li>Learn the necessary underlying mathematical concepts</li>
<li>Consider the terminology and notation used in the problem:</li>
</ol>
<p>● What sort of a problem is it?</p>
<p>● What is being asked?</p>
<p>● What do the terms mean?</p>
<p>● Is there enough information or is more information needed?</p>
<p>● What is known or unknown?</p>
<ol start="2" type="1">
<li><strong>Thinking Time</strong>: Devise a plan</li>
</ol>
<ol type="a">
<li>You must start somewhere so try something. How are you going to attack the problem?</li>
<li>Possible strategies: (i. e. reach into your bag of tricks)</li>
</ol>
<pre><code>●   Draw pictures

●   Use a variable and choose helpful names for variables or unknowns.

●   Be systematic.

●   Solve a simpler version of the problem.

●   Guess and check. Trial and error. Guess and test. (guessing is OK.)

●   Look for a pattern or patterns.

●   Make a list.</code></pre>
<ol start="3" type="a">
<li>Once you understand what the problem is, if you are stumped or stuck, set the problem aside for a while. Your subconscious mind may keep working on it.</li>
<li>Moving on to think about other things may help you stay relaxed, flexible, and creative rather than becoming tense, frustrated, and forced in your efforts to solve the problem.</li>
</ol>
<ol start="3" type="1">
<li><strong>Insight</strong>: Carry out the plan</li>
</ol>
<ol type="a">
<li>Once you have an idea for a new approach, jot it down immediately. When you have time, try it out and see if it leads to a solution.</li>
<li>If the plan does not seem to be working, then start over and try another approach. Often the first approach does not work. Do not worry, just because an approach does not work, it does not mean you did it wrong. You actually accomplished something, knowing a way does not work is part of the process of elimination.</li>
<li>Once you have thought about a problem or returned to it enough times, you will often have a flash of insight: a new idea to try or a new perspective on how to approach solving the problem.</li>
<li>The key is to keep trying until something works.</li>
</ol>
<ol start="4" type="1">
<li><strong>Verification</strong>: Look back.</li>
</ol>
<ol type="a">
<li>Once you have a potential solution, check to see if it works.</li>
</ol>
<pre><code>●   Did you answer the question?

●   Is your result reasonable?

●   Double check to make sure that all of the conditions related to the problem are satisfied.

●   Double check any computations involved in finding your solution.</code></pre>
<ol start="2" type="a">
<li>If you find that your solution does not work, there may only be a simple mistake. Try to fix or modify your current attempt before scrapping it. Remember what you tried- it is likely that at least part of it will end up being useful.</li>
<li>Is there another way of doing the problem which may be simpler? (You need to become flexible in your thinking. There usually is not one right away.)</li>
<li>Can the problem or method be generalized so as to be useful for future problems?</li>
</ol>
<p><strong>C. Problem Solving Strategies</strong> Problem solving strategies maybe develop in many ways. First, the ability to use strategies develops with experience and practice. Second, strategies themselves can become more abstract and complex.</p>
<p>There are simple and common problem solving strategies, to mention a few:</p>
<p>● Guess (This includes guess-and-check and guess-and-improve)</p>
<p>● Act it Out (Act it out and use equipment)</p>
<p>● Draw (This includes drawing pictures and diagrams)</p>
<p>● List/Tabulate (This includes making a table)</p>
<p><strong>Guess-and-check</strong> is a classic technique. While it may not be very efficient or reliable, sometimes it’s all one has to work with. One nice thing about this technique is the low level of effort it requires. It can be a great way to relax the mind. <strong>Guess-and-check</strong> is one of the simplest strategies. Anyone can guess an answer. If they can also check that the guess fits the conditions of the problem, then they have mastered guess and check. Guess-and-improve is slightly more sophisticated than the guess-and-check. The idea is that you use your first incorrect guess to make an improved next guess. In relatively straightforward problems like that, it is often fairly easy to see how to improve the last guess. In some problems though, where there are more variables, it may not be clear at first which way to change the guessing jigsaw and crossword puzzles are usually solved using guess-and-check and guess-and-improve.</p>
<p>There are pros and cons for <strong>Act-It-Out</strong> strategy. It is an effective strategy for demonstration purposes and to have a better grip of the problem on hand. Devices use to act out the problem are considered equipment. Act-It-Out strategy has limited application. Simple division operation problem can be solved by this strategy. A class of 32 elementary graders maybe asked: To effectively do the task, we shall divide the class. How many group of five can you make? Then, they can act-it-out by forming groups of five.</p>
<p>To <strong>draw pictures</strong>, Venn diagram, sketches, maps and other representations help solve mathematical problems, as well as problems in mechanics (physics). Problems concerning vector addition, in fact, are solved in two ways: graphical or drawing methods and analytical or mathematical method. In doing so, precise measurements and careful drawing lead to accurate solution.</p>
<p>Creating systematic <strong>lists</strong> and organized <strong>tables</strong> helps discover some hidden hints towards solution of some problems. To help solve logic problems, tables with ticks and crosses are often used. Tables can also be an efficient way of finding number patterns. Work and age problems are easier solved by tabulating the known facts and relations. Lists maybe organized following rules like highest to lowest, most frequent to less frequent, excellent to very unsatisfactory, etc. scores may be listed in an array in decreasing manner for item analysis purposes. Problems in statistics may be solved by listing, tallying and tabulating data</p>
<p><strong>D. Mathematical Problems Involving Patterns</strong></p>
<p>Finding patterns is an important problem-solving strategy because many problems are similar and fall into predictable patterns. A pattern is a regular, systematic repetition and may be numerical, visual, or sequential. Patterns show how things are connected, how things work and how a group of objects acts in the same way.</p>
<p><strong>Example No.&nbsp;1</strong>: Find-a-pattern problem solving strategy.</p>
<p>▪ Given the following diagram, find the number of dots and lines by completing the table.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>